
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>smtplib ---SMTP协议客户端 &#8212; Python 3.9.7 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.9.7 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="smtpd --- SMTP 服务器" href="smtpd.html" />
    <link rel="prev" title="nntplib --- NNTP protocol client" href="nntplib.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/smtplib.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP 服务器"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="nntplib.html" title="nntplib --- NNTP protocol client"
             accesskey="P">上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.9.7 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">互联网协议和支持</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-smtplib">
<span id="smtplib-smtp-protocol-client"></span><h1><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> ---SMTP协议客户端<a class="headerlink" href="#module-smtplib" title="永久链接至标题">¶</a></h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/smtplib.py">Lib/smtplib.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 模块定义了一个 SMTP 客户端会话对象，该对象可将邮件发送到 Internet 上带有 SMTP 或 ESMTP 接收程序的计算机。 关于 SMTP 和 ESMTP 操作的详情请参阅 <span class="target" id="index-18"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a> (简单邮件传输协议) 和 <span class="target" id="index-19"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a> (SMTP 服务扩展)。</p>
<dl class="class">
<dt id="smtplib.SMTP">
<em class="property">class </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTP</code><span class="sig-paren">(</span><em class="sig-param">host=''</em>, <em class="sig-param">port=0</em>, <em class="sig-param">local_hostname=None</em>, <span class="optional">[</span><em class="sig-param">timeout</em>, <span class="optional">]</span><em class="sig-param">source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP" title="永久链接至目标">¶</a></dt>
<dd><p>一个 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 实例就是一个封装好的 SMTP 连接。该实例具有的方法支持所有 SMTP 和 ESMTP 操作。如果传入了可选参数 host 和 port，那么将在初始化时使用这些参数调用 SMTP <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 方法。如果传入了 <em>local_hostname</em>，它将在 HELO/EHLO 命令中被用作本地主机的 FQDN。否则将使用 <a class="reference internal" href="socket.html#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getfqdn()</span></code></a> 找到本地主机名。如果 <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 返回了成功码以外的内容，则引发 <a class="reference internal" href="#smtplib.SMTPConnectError" title="smtplib.SMTPConnectError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPConnectError</span></code></a> 异常。可选参数 <em>timeout</em> 指定阻塞操作（如连接尝试）的超时（以秒为单位，如果未指定超时，将使用全局默认超时设置）。到达超时时长后会引发 <a class="reference internal" href="socket.html#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.timeout</span></code></a> 异常。可选参数 source_address 允许在有多张网卡的计算机中绑定到某些特定的源地址，和/或绑定到某些特定的源 TCP 端口。在连接前，套接字需要绑定一个 2 元组 (host, port) 作为其源地址。如果省略，或者是主机为 <code class="docutils literal notranslate"><span class="pre">''</span></code> 和/或端口为 0，则将使用操作系统默认行为。</p>
<p>正常使用时，只需要初始化或 connect 方法，<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> 方法，再加上 <a class="reference internal" href="#smtplib.SMTP.quit" title="smtplib.SMTP.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SMTP.quit()</span></code></a> 方法即可。下文包括了一个示例。</p>
<p><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 类支持 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句。当这样使用时，<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 语句一退出就会自动发出 SMTP <code class="docutils literal notranslate"><span class="pre">QUIT</span></code> 命令。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">smtplib</span> <span class="kn">import</span> <span class="n">SMTP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;domain.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">smtp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">smtp</span><span class="o">.</span><span class="n">noop</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">(250, b&#39;Ok&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="audit-hook"><p>All commands will raise an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a>
<code class="docutils literal notranslate"><span class="pre">smtplib.SMTP.send</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">data</span></code>,
where <code class="docutils literal notranslate"><span class="pre">data</span></code> is the bytes about to be sent to the remote host.</p>
</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>支持了 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>source_address argument was added.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能: </span>The SMTPUTF8 extension (<span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>) is now supported.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>If the <em>timeout</em> parameter is set to be zero, it will raise a
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a> to prevent the creation of a non-blocking socket</p>
</div>
</dd></dl>

<dl class="class">
<dt id="smtplib.SMTP_SSL">
<em class="property">class </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTP_SSL</code><span class="sig-paren">(</span><em class="sig-param">host=''</em>, <em class="sig-param">port=0</em>, <em class="sig-param">local_hostname=None</em>, <em class="sig-param">keyfile=None</em>, <em class="sig-param">certfile=None</em>, <span class="optional">[</span><em class="sig-param">timeout</em>, <span class="optional">]</span><em class="sig-param">context=None</em>, <em class="sig-param">source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP_SSL" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP_SSL</span></code></a> 实例与 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 实例的行为完全相同。在开始连接就需要 SSL，且 <code class="xref py py-meth docutils literal notranslate"><span class="pre">starttls()</span></code> 不适合的情况下，应该使用 <a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP_SSL</span></code></a>。如果未指定 <em>host</em>，则使用 localhost。如果 <em>port</em> 为 0，则使用标准 SMTP-over-SSL 端口（465）。可选参数 <em>local_hostname</em>、<em>timeout</em> 和 <em>source_address</em> 的含义与 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 类中的相同。可选参数 <em>context</em> 是一个 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 对象，可以从多个方面配置安全连接。请阅读 <a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">安全考量</span></a> 以获取最佳实践。</p>
<p><em>keyfile</em> and <em>certfile</em> are a legacy alternative to <em>context</em>, and can
point to a PEM formatted private key and certificate chain file for the
SSL connection.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>context</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>source_address argument was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>本类现在支持通过 <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ssl.SSLContext.check_hostname</span></code></a> 和 <em>服务器名称提示</em> （参阅 <a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a>）进行主机名检查。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span><em>keyfile</em> 和 <em>certfile</em> 已弃用并转而推荐 <em>context</em>。 请改用 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a> 或让 <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 为你选择系统所信任的 CA 证书。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>If the <em>timeout</em> parameter is set to be zero, it will raise a
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a> to prevent the creation of a non-blocking socket</p>
</div>
</dd></dl>

<dl class="class">
<dt id="smtplib.LMTP">
<em class="property">class </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">LMTP</code><span class="sig-paren">(</span><em class="sig-param">host=''</em>, <em class="sig-param">port=LMTP_PORT</em>, <em class="sig-param">local_hostname=None</em>, <em class="sig-param">source_address=None</em><span class="optional">[</span>, <em class="sig-param">timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.LMTP" title="永久链接至目标">¶</a></dt>
<dd><p>LMTP 协议与 ESMTP 非常相似，它很大程度上基于标准的 SMTP 客户端。将 Unix 套接字用于 LMTP 是很常见的，因此 <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> 方法支持 Unix 套接字，也支持常规的 host:port 服务器。可选参数 local_hostname 和 source_address 的含义与 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 类中的相同。要指定 Unix 套接字，<em>host</em> 必须使用绝对路径，以 '/' 开头。</p>
<p>Authentication is supported, using the regular SMTP mechanism. When using a
Unix socket, LMTP generally don't support or require any authentication, but
your mileage might vary.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>The optional <em>timeout</em> parameter was added.</p>
</div>
</dd></dl>

<p>A nice selection of exceptions is defined as well:</p>
<dl class="exception">
<dt id="smtplib.SMTPException">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPException</code><a class="headerlink" href="#smtplib.SMTPException" title="永久链接至目标">¶</a></dt>
<dd><p>Subclass of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> that is the base exception class for all
the other exceptions provided by this module.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>SMTPException became subclass of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPServerDisconnected">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPServerDisconnected</code><a class="headerlink" href="#smtplib.SMTPServerDisconnected" title="永久链接至目标">¶</a></dt>
<dd><p>This exception is raised when the server unexpectedly disconnects, or when an
attempt is made to use the <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> instance before connecting it to a
server.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPResponseException">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPResponseException</code><a class="headerlink" href="#smtplib.SMTPResponseException" title="永久链接至目标">¶</a></dt>
<dd><p>Base class for all exceptions that include an SMTP error code. These exceptions
are generated in some instances when the SMTP server returns an error code.  The
error code is stored in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">smtp_code</span></code> attribute of the error, and the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">smtp_error</span></code> attribute is set to the error message.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPSenderRefused">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPSenderRefused</code><a class="headerlink" href="#smtplib.SMTPSenderRefused" title="永久链接至目标">¶</a></dt>
<dd><p>Sender address refused.  In addition to the attributes set by on all
<a class="reference internal" href="#smtplib.SMTPResponseException" title="smtplib.SMTPResponseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPResponseException</span></code></a> exceptions, this sets 'sender' to the string that
the SMTP server refused.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPRecipientsRefused">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPRecipientsRefused</code><a class="headerlink" href="#smtplib.SMTPRecipientsRefused" title="永久链接至目标">¶</a></dt>
<dd><p>All recipient addresses refused.  The errors for each recipient are accessible
through the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">recipients</span></code>, which is a dictionary of exactly the
same sort as <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SMTP.sendmail()</span></code></a> returns.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPDataError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPDataError</code><a class="headerlink" href="#smtplib.SMTPDataError" title="永久链接至目标">¶</a></dt>
<dd><p>The SMTP server refused to accept the message data.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPConnectError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPConnectError</code><a class="headerlink" href="#smtplib.SMTPConnectError" title="永久链接至目标">¶</a></dt>
<dd><p>Error occurred during establishment of a connection  with the server.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPHeloError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPHeloError</code><a class="headerlink" href="#smtplib.SMTPHeloError" title="永久链接至目标">¶</a></dt>
<dd><p>The server refused our <code class="docutils literal notranslate"><span class="pre">HELO</span></code> message.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPNotSupportedError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPNotSupportedError</code><a class="headerlink" href="#smtplib.SMTPNotSupportedError" title="永久链接至目标">¶</a></dt>
<dd><p>The command or option attempted is not supported by the server.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPAuthenticationError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPAuthenticationError</code><a class="headerlink" href="#smtplib.SMTPAuthenticationError" title="永久链接至目标">¶</a></dt>
<dd><p>SMTP authentication went wrong.  Most probably the server didn't accept the
username/password combination provided.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a> - Simple Mail Transfer Protocol</dt><dd><p>Protocol definition for SMTP.  This document covers the model, operating
procedure, and protocol details for SMTP.</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a> - SMTP Service Extensions</dt><dd><p>Definition of the ESMTP extensions for SMTP.  This describes a framework for
extending SMTP with new commands, supporting dynamic discovery of the commands
provided by the server, and defines a few additional commands.</p>
</dd>
</dl>
</div>
<div class="section" id="smtp-objects">
<span id="id1"></span><h2>SMTP Objects<a class="headerlink" href="#smtp-objects" title="永久链接至标题">¶</a></h2>
<p>An <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> instance has the following methods:</p>
<dl class="method">
<dt id="smtplib.SMTP.set_debuglevel">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">set_debuglevel</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.set_debuglevel" title="永久链接至目标">¶</a></dt>
<dd><p>Set the debug output level.  A value of 1 or <code class="docutils literal notranslate"><span class="pre">True</span></code> for <em>level</em> results in
debug messages for connection and for all messages sent to and received from
the server.  A value of 2 for <em>level</em> results in these messages being
timestamped.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>Added debuglevel 2.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.docmd">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">docmd</code><span class="sig-paren">(</span><em class="sig-param">cmd</em>, <em class="sig-param">args=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.docmd" title="永久链接至目标">¶</a></dt>
<dd><p>Send a command <em>cmd</em> to the server.  The optional argument <em>args</em> is simply
concatenated to the command, separated by a space.</p>
<p>This returns a 2-tuple composed of a numeric response code and the actual
response line (multiline responses are joined into one long line.)</p>
<p>In normal operation it should not be necessary to call this method explicitly.
It is used to implement other methods and may be useful for testing private
extensions.</p>
<p>If the connection to the server is lost while waiting for the reply,
<a class="reference internal" href="#smtplib.SMTPServerDisconnected" title="smtplib.SMTPServerDisconnected"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPServerDisconnected</span></code></a> will be raised.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.connect">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">connect</code><span class="sig-paren">(</span><em class="sig-param">host='localhost'</em>, <em class="sig-param">port=0</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.connect" title="永久链接至目标">¶</a></dt>
<dd><p>连接到某个主机的某个端口。默认是连接到 localhost 的标准 SMTP 端口（25）上。如果主机名以冒号 (<code class="docutils literal notranslate"><span class="pre">':'</span></code>) 结尾，后跟数字，则该后缀将被删除，且数字将视作要使用的端口号。如果在实例化时指定了 host，则构造函数会自动调用本方法。返回包含响应码和响应消息的 2 元组，它们由服务器在其连接响应中发送。</p>
<p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">smtplib.connect</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">host</span></code>, <code class="docutils literal notranslate"><span class="pre">port</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.helo">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">helo</code><span class="sig-paren">(</span><em class="sig-param">name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.helo" title="永久链接至目标">¶</a></dt>
<dd><p>Identify yourself to the SMTP server using <code class="docutils literal notranslate"><span class="pre">HELO</span></code>.  The hostname argument
defaults to the fully qualified domain name of the local host.
The message returned by the server is stored as the <code class="xref py py-attr docutils literal notranslate"><span class="pre">helo_resp</span></code> attribute
of the object.</p>
<p>In normal operation it should not be necessary to call this method explicitly.
It will be implicitly called by the <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> when necessary.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.ehlo">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">ehlo</code><span class="sig-paren">(</span><em class="sig-param">name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.ehlo" title="永久链接至目标">¶</a></dt>
<dd><p>使用 <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> 向 ESMTP 服务器标识自身。hostname 参数默认为 localhost 的标准域名。使用 <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_extn()</span></code></a> 来检查响应中的 ESMTP 选项，并将它们保存起来。还给一些信息性的属性赋值：服务器返回的消息存储为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ehlo_resp</span></code> 属性；根据服务器是否支持 ESMTP，将 <code class="xref py py-attr docutils literal notranslate"><span class="pre">does_esmtp</span></code> 设置为 true 或 false；而 <code class="xref py py-attr docutils literal notranslate"><span class="pre">esmtp_features</span></code> 是一个字典，包含该服务器支持的 SMTP 服务扩展的名称及参数（如果有参数）。</p>
<p>Unless you wish to use <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_extn()</span></code></a> before sending mail, it should not be
necessary to call this method explicitly.  It will be implicitly called by
<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> when necessary.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.ehlo_or_helo_if_needed">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">ehlo_or_helo_if_needed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.ehlo_or_helo_if_needed" title="永久链接至目标">¶</a></dt>
<dd><p>This method calls <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehlo()</span></code></a> and/or <a class="reference internal" href="#smtplib.SMTP.helo" title="smtplib.SMTP.helo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">helo()</span></code></a> if there has been no
previous <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session.  It tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>
first.</p>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.has_extn">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">has_extn</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.has_extn" title="永久链接至目标">¶</a></dt>
<dd><p>Return <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> if <em>name</em> is in the set of SMTP service extensions returned
by the server, <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> otherwise. Case is ignored.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.verify">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">verify</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.verify" title="永久链接至目标">¶</a></dt>
<dd><p>Check the validity of an address on this server using SMTP <code class="docutils literal notranslate"><span class="pre">VRFY</span></code>. Returns a
tuple consisting of code 250 and a full <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> address (including human
name) if the user address is valid. Otherwise returns an SMTP error code of 400
or greater and an error string.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Many sites disable SMTP <code class="docutils literal notranslate"><span class="pre">VRFY</span></code> in order to foil spammers.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.login">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">login</code><span class="sig-paren">(</span><em class="sig-param">user</em>, <em class="sig-param">password</em>, <em class="sig-param">*</em>, <em class="sig-param">initial_response_ok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.login" title="永久链接至目标">¶</a></dt>
<dd><p>Log in on an SMTP server that requires authentication. The arguments are the
username and the password to authenticate with. If there has been no previous
<code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session, this method tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>
first. This method will return normally if the authentication was successful, or
may raise the following exceptions:</p>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPAuthenticationError" title="smtplib.SMTPAuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPAuthenticationError</span></code></a></dt><dd><p>The server didn't accept the username/password combination.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command is not supported by the server.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPException</span></code></a></dt><dd><p>No suitable authentication method was found.</p>
</dd>
</dl>
<p>Each of the authentication methods supported by <a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> are tried in
turn if they are advertised as supported by the server.  See <a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">auth()</span></code></a>
for a list of supported authentication methods.  <em>initial_response_ok</em> is
passed through to <a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">auth()</span></code></a>.</p>
<p>Optional keyword argument <em>initial_response_ok</em> specifies whether, for
authentication methods that support it, an &quot;initial response&quot; as specified
in <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a> can be sent along with the <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command, rather than
requiring a challenge/response.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> may be raised, and the
<em>initial_response_ok</em> parameter was added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.auth">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">auth</code><span class="sig-paren">(</span><em class="sig-param">mechanism</em>, <em class="sig-param">authobject</em>, <em class="sig-param">*</em>, <em class="sig-param">initial_response_ok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.auth" title="永久链接至目标">¶</a></dt>
<dd><p>Issue an <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command for the specified authentication
<em>mechanism</em>, and handle the challenge response via <em>authobject</em>.</p>
<p><em>mechanism</em> specifies which authentication mechanism is to
be used as argument to the <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command; the valid values are
those listed in the <code class="docutils literal notranslate"><span class="pre">auth</span></code> element of <code class="xref py py-attr docutils literal notranslate"><span class="pre">esmtp_features</span></code>.</p>
<p><em>authobject</em> must be a callable object taking an optional single argument:</p>
<blockquote>
<div><p>data = authobject(challenge=None)</p>
</div></blockquote>
<p>If optional keyword argument <em>initial_response_ok</em> is true,
<code class="docutils literal notranslate"><span class="pre">authobject()</span></code> will be called first with no argument.  It can return the
<span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a> &quot;initial response&quot; ASCII <code class="docutils literal notranslate"><span class="pre">str</span></code> which will be encoded and sent with
the <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command as below.  If the <code class="docutils literal notranslate"><span class="pre">authobject()</span></code> does not support an
initial response (e.g. because it requires a challenge), it should return
<code class="docutils literal notranslate"><span class="pre">None</span></code> when called with <code class="docutils literal notranslate"><span class="pre">challenge=None</span></code>.  If <em>initial_response_ok</em> is
false, then <code class="docutils literal notranslate"><span class="pre">authobject()</span></code> will not be called first with <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If the initial response check returns <code class="docutils literal notranslate"><span class="pre">None</span></code>, or if <em>initial_response_ok</em> is
false, <code class="docutils literal notranslate"><span class="pre">authobject()</span></code> will be called to process the server's challenge
response; the <em>challenge</em> argument it is passed will be a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.  It
should return ASCII <code class="docutils literal notranslate"><span class="pre">str</span></code> <em>data</em> that will be base64 encoded and sent to the
server.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> class provides <code class="docutils literal notranslate"><span class="pre">authobjects</span></code> for the <code class="docutils literal notranslate"><span class="pre">CRAM-MD5</span></code>, <code class="docutils literal notranslate"><span class="pre">PLAIN</span></code>,
and <code class="docutils literal notranslate"><span class="pre">LOGIN</span></code> mechanisms; they are named <code class="docutils literal notranslate"><span class="pre">SMTP.auth_cram_md5</span></code>,
<code class="docutils literal notranslate"><span class="pre">SMTP.auth_plain</span></code>, and <code class="docutils literal notranslate"><span class="pre">SMTP.auth_login</span></code> respectively.  They all require
that the <code class="docutils literal notranslate"><span class="pre">user</span></code> and <code class="docutils literal notranslate"><span class="pre">password</span></code> properties of the <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> instance are
set to appropriate values.</p>
<p>User code does not normally need to call <code class="docutils literal notranslate"><span class="pre">auth</span></code> directly, but can instead
call the <a class="reference internal" href="#smtplib.SMTP.login" title="smtplib.SMTP.login"><code class="xref py py-meth docutils literal notranslate"><span class="pre">login()</span></code></a> method, which will try each of the above mechanisms
in turn, in the order listed.  <code class="docutils literal notranslate"><span class="pre">auth</span></code> is exposed to facilitate the
implementation of authentication methods not (or not yet) supported
directly by <a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.starttls">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">starttls</code><span class="sig-paren">(</span><em class="sig-param">keyfile=None</em>, <em class="sig-param">certfile=None</em>, <em class="sig-param">context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.starttls" title="永久链接至目标">¶</a></dt>
<dd><p>Put the SMTP connection in TLS (Transport Layer Security) mode.  All SMTP
commands that follow will be encrypted.  You should then call <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehlo()</span></code></a>
again.</p>
<p>If <em>keyfile</em> and <em>certfile</em> are provided, they are used to create an
<a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>.</p>
<p>Optional <em>context</em> parameter is an <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> object; This is
an alternative to using a keyfile and a certfile and if specified both
<em>keyfile</em> and <em>certfile</em> should be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If there has been no previous <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session,
this method tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> first.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span><em>keyfile</em> 和 <em>certfile</em> 已弃用并转而推荐 <em>context</em>。 请改用 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a> 或让 <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 为你选择系统所信任的 CA 证书。</p>
</div>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt><dd><p>The server does not support the STARTTLS extension.</p>
</dd>
<dt><a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a></dt><dd><p>SSL/TLS support is not available to your Python interpreter.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>context</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>The method now supports hostname check with
<code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code> and <em>Server Name Indicator</em> (see
<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_SNI</span></code></a>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>The error raised for lack of STARTTLS support is now the
<a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> subclass instead of the base
<a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPException</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.sendmail">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">sendmail</code><span class="sig-paren">(</span><em class="sig-param">from_addr</em>, <em class="sig-param">to_addrs</em>, <em class="sig-param">msg</em>, <em class="sig-param">mail_options=()</em>, <em class="sig-param">rcpt_options=()</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.sendmail" title="永久链接至目标">¶</a></dt>
<dd><p>发送邮件。必要参数是一个 <span class="target" id="index-20"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> 发件地址字符串，一个 <span class="target" id="index-21"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> 收件地址字符串列表（裸字符串将被视为含有 1 个地址的列表），以及一个消息字符串。调用者可以将 ESMTP 选项列表（如 <code class="docutils literal notranslate"><span class="pre">8bitmime</span></code>）作为 <em>mail_options</em> 传入，用于 <code class="docutils literal notranslate"><span class="pre">MAIL</span> <span class="pre">FROM</span></code> 命令。需要与所有 <code class="docutils literal notranslate"><span class="pre">RCPT</span></code> 命令一起使用的 ESMTP 选项（如 <code class="docutils literal notranslate"><span class="pre">DSN</span></code> 命令）可以作为 <em>rcpt_options</em> 传入。（如果需要对不同的收件人使用不同的 ESMTP 选项，则必须使用底层的方法来发送消息，如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">mail()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">rcpt()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">data()</span></code>。）</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The <em>from_addr</em> and <em>to_addrs</em> parameters are used to construct the message
envelope used by the transport agents.  <code class="docutils literal notranslate"><span class="pre">sendmail</span></code> does not modify the
message headers in any way.</p>
</div>
<p><em>msg</em> may be a string containing characters in the ASCII range, or a byte
string.  A string is encoded to bytes using the ascii codec, and lone <code class="docutils literal notranslate"><span class="pre">\r</span></code>
and <code class="docutils literal notranslate"><span class="pre">\n</span></code> characters are converted to <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> characters.  A byte string is
not modified.</p>
<p>If there has been no previous <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session, this
method tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> first. If the server does ESMTP, message size and
each of the specified options will be passed to it (if the option is in the
feature set the server advertises).  If <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> fails, <code class="docutils literal notranslate"><span class="pre">HELO</span></code> will be tried
and ESMTP options suppressed.</p>
<p>This method will return normally if the mail is accepted for at least one
recipient. Otherwise it will raise an exception.  That is, if this method does
not raise an exception, then someone should get your mail. If this method does
not raise an exception, it returns a dictionary, with one entry for each
recipient that was refused.  Each entry contains a tuple of the SMTP error code
and the accompanying error message sent by the server.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> is included in <em>mail_options</em>, and the server supports it,
<em>from_addr</em> and <em>to_addrs</em> may contain non-ASCII characters.</p>
<p>This method may raise the following exceptions:</p>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPRecipientsRefused" title="smtplib.SMTPRecipientsRefused"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPRecipientsRefused</span></code></a></dt><dd><p>All recipients were refused.  Nobody got the mail.  The <code class="xref py py-attr docutils literal notranslate"><span class="pre">recipients</span></code>
attribute of the exception object is a dictionary with information about the
refused recipients (like the one returned when at least one recipient was
accepted).</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPSenderRefused" title="smtplib.SMTPSenderRefused"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPSenderRefused</span></code></a></dt><dd><p>The server didn't accept the <em>from_addr</em>.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPDataError" title="smtplib.SMTPDataError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPDataError</span></code></a></dt><dd><p>The server replied with an unexpected error code (other than a refusal of a
recipient).</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> was given in the <em>mail_options</em> but is not supported by the
server.</p>
</dd>
</dl>
<p>Unless otherwise noted, the connection will be open even after an exception is
raised.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span><em>msg</em> may be a byte string.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span><code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> support added, and <a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> may be
raised if <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> is specified but the server does not support it.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.send_message">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">send_message</code><span class="sig-paren">(</span><em class="sig-param">msg</em>, <em class="sig-param">from_addr=None</em>, <em class="sig-param">to_addrs=None</em>, <em class="sig-param">mail_options=()</em>, <em class="sig-param">rcpt_options=()</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.send_message" title="永久链接至目标">¶</a></dt>
<dd><p>本方法是一种快捷方法，用于带着消息调用 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a>，消息由 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> 对象表示。参数的含义与 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> 中的相同，除了 <em>msg</em>，它是一个 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 对象。</p>
<p>如果 <em>from_addr</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或 <em>to_addrs</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，那么``send_message``将根据 <span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>，从 <em>msg</em> 头部提取地址填充下列参数：如果头部存在 <em class="mailheader">Sender</em> 字段，则用它填充 <em>from_addr</em>，不存在则用 <em class="mailheader">From</em> 字段填充 <em>from_addr</em>。<em>to_addrs</em> 组合了 <em>msg</em> 中的 <em class="mailheader">To</em>, <em class="mailheader">Cc</em> 和 <em class="mailheader">Bcc</em> 字段的值（字段存在的情况下）。如果一组 <em class="mailheader">Resent-*</em> 头部恰好出现在 message 中，那么就忽略常规的头部，改用 <em class="mailheader">Resent-*</em> 头部。如果 message 包含多组 <em class="mailheader">Resent-*</em> 头部，则引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>，因为无法明确检测出哪一组 <em class="mailheader">Resent-</em> 头部是最新的。</p>
<p><code class="docutils literal notranslate"><span class="pre">send_message</span></code> 使用 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a> 来序列化 <em>msg</em>，且将 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> 作为 <em>linesep</em>，并调用 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> 来传输序列化后的结果。无论 <em>from_addr</em> 和 <em>to_addrs</em> 的值为何，<code class="docutils literal notranslate"><span class="pre">send_message</span></code> 都不会传输 <em>msg</em> 中可能出现的 <em class="mailheader">Bcc</em> 或 <em class="mailheader">Resent-Bcc</em> 头部。如果 <em>from_addr</em> 和 <em>to_addrs</em> 中的某个地址包含非 ASCII 字符，且服务器没有声明支持 <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code>，则引发 <code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupported</span></code> 错误。如果服务器支持，则 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 将按新克隆的 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 进行序列化，其中的 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> 属性被设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，且 <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> 和 <code class="docutils literal notranslate"><span class="pre">BODY=8BITMIME</span></code> 被添加到 <em>mail_options</em> 中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能: </span>Support for internationalized addresses (<code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.quit">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">quit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.quit" title="永久链接至目标">¶</a></dt>
<dd><p>Terminate the SMTP session and close the connection.  Return the result of
the SMTP <code class="docutils literal notranslate"><span class="pre">QUIT</span></code> command.</p>
</dd></dl>

<p>Low-level methods corresponding to the standard SMTP/ESMTP commands <code class="docutils literal notranslate"><span class="pre">HELP</span></code>,
<code class="docutils literal notranslate"><span class="pre">RSET</span></code>, <code class="docutils literal notranslate"><span class="pre">NOOP</span></code>, <code class="docutils literal notranslate"><span class="pre">MAIL</span></code>, <code class="docutils literal notranslate"><span class="pre">RCPT</span></code>, and <code class="docutils literal notranslate"><span class="pre">DATA</span></code> are also supported.
Normally these do not need to be called directly, so they are not documented
here.  For details, consult the module code.</p>
</div>
<div class="section" id="smtp-example">
<span id="id2"></span><h2>SMTP Example<a class="headerlink" href="#smtp-example" title="永久链接至标题">¶</a></h2>
<p>This example prompts the user for addresses needed in the message envelope ('To'
and 'From' addresses), and the message to be delivered.  Note that the headers
to be included with the message must be included in the message as entered; this
example doesn't do any processing of the <span class="target" id="index-12"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> headers.  In particular, the
'To' and 'From' addresses must be included in the message headers explicitly.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">smtplib</span>

<span class="k">def</span> <span class="nf">prompt</span><span class="p">(</span><span class="n">prompt</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">&quot;From: &quot;</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">&quot;To: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter message, end with ^D (Unix) or ^Z (Windows):&quot;</span><span class="p">)</span>

<span class="c1"># Add the From: and To: headers at the start!</span>
<span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;From: </span><span class="si">%s</span><span class="se">\r\n</span><span class="s2">To: </span><span class="si">%s</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span>
       <span class="o">%</span> <span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">toaddrs</span><span class="p">)))</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">line</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Message length is&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">set_debuglevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>In general, you will want to use the <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> package's features to
construct an email message, which you can then send
via <a class="reference internal" href="#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_message()</span></code></a>; see <a class="reference internal" href="email.examples.html#email-examples"><span class="std std-ref">email: 示例</span></a>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code> ---SMTP协议客户端</a><ul>
<li><a class="reference internal" href="#smtp-objects">SMTP Objects</a></li>
<li><a class="reference internal" href="#smtp-example">SMTP Example</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="nntplib.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code> --- NNTP protocol client</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="smtpd.html"
                        title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtpd</span></code> --- SMTP 服务器</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.9/Doc/library/smtplib.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP 服务器"
             >下一页</a> |</li>
        <li class="right" >
          <a href="nntplib.html" title="nntplib --- NNTP protocol client"
             >上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.9.7 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >互联网协议和支持</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2021, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 9月 30, 2021.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>